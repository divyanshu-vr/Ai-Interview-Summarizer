{"version":3,"file":"static/js/492.a6cc0319.chunk.js","mappings":"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","sources":["services/whisperService.js"],"sourcesContent":["/**\r\n * WhisperService - Manages Whisper worker for speech recognition\r\n * Provides a clean interface for the main thread to interact with Whisper\r\n */\r\n\r\nclass WhisperService {\r\n  constructor() {\r\n    this.worker = null;\r\n    this.isInitialized = false;\r\n    this.isInitializing = false;\r\n    this.messageId = 0;\r\n    this.pendingMessages = new Map();\r\n    this.currentModel = 'Xenova/whisper-tiny.en';\r\n    \r\n    // Callbacks\r\n    this.onReady = null;\r\n    this.onError = null;\r\n    this.onProgress = null;\r\n  }\r\n\r\n  /**\r\n   * Initialize the Whisper service\r\n   * @param {string} modelName - Whisper model to use\r\n   * @returns {Promise<boolean>} Success status\r\n   */\r\n  async initialize(modelName = 'Xenova/whisper-tiny.en') {\r\n    if (this.isInitialized || this.isInitializing) {\r\n      return this.isInitialized;\r\n    }\r\n\r\n    this.isInitializing = true;\r\n\r\n    try {\r\n      // Create worker from public directory (Create React App compatible)\r\n      try {\r\n        this.worker = new Worker('/whisperWorker.js');\r\n      } catch (error) {\r\n        console.error('Failed to create Whisper worker:', error);\r\n        throw new Error('Whisper worker not available. Please ensure whisperWorker.js is in the public directory.');\r\n      }\r\n\r\n      // Set up worker message handling\r\n      this.worker.onmessage = this.handleWorkerMessage.bind(this);\r\n      this.worker.onerror = this.handleWorkerError.bind(this);\r\n\r\n      // Wait for worker to be ready\r\n      await this.waitForWorkerReady();\r\n\r\n      // Initialize the model\r\n      const result = await this.sendMessage('initialize', { modelName });\r\n      \r\n      if (result.success) {\r\n        this.isInitialized = true;\r\n        this.currentModel = modelName;\r\n        console.log('WhisperService initialized successfully');\r\n        \r\n        if (this.onReady) {\r\n          this.onReady();\r\n        }\r\n        \r\n        return true;\r\n      } else {\r\n        throw new Error(result.error || 'Failed to initialize Whisper model');\r\n      }\r\n\r\n    } catch (error) {\r\n      console.error('WhisperService initialization failed:', error);\r\n      this.handleError('Initialization failed', error);\r\n      return false;\r\n    } finally {\r\n      this.isInitializing = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wait for worker to send ready message\r\n   * @returns {Promise<void>}\r\n   */\r\n  waitForWorkerReady() {\r\n    return new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(() => {\r\n        reject(new Error('Worker ready timeout'));\r\n      }, 30000); // 30 second timeout\r\n\r\n      const handleMessage = (event) => {\r\n        if (event.data.type === 'ready') {\r\n          clearTimeout(timeout);\r\n          this.worker.removeEventListener('message', handleMessage);\r\n          resolve();\r\n        }\r\n      };\r\n\r\n      this.worker.addEventListener('message', handleMessage);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Transcribe audio data\r\n   * @param {Float32Array} audioData - Audio samples\r\n   * @param {Object} options - Transcription options\r\n   * @returns {Promise<Object>} Transcription result\r\n   */\r\n  async transcribe(audioData, options = {}) {\r\n    if (!this.isInitialized) {\r\n      throw new Error('WhisperService not initialized');\r\n    }\r\n\r\n    if (!audioData || audioData.length === 0) {\r\n      return {\r\n        text: '',\r\n        confidence: 0,\r\n        segments: [],\r\n        processingTime: 0\r\n      };\r\n    }\r\n\r\n    try {\r\n      const result = await this.sendMessage('transcribe', {\r\n        audioData: audioData,\r\n        options: {\r\n          language: options.language || 'english',\r\n          chunkLength: options.chunkLength || 30,\r\n          strideLength: options.strideLength || 5,\r\n          ...options\r\n        }\r\n      });\r\n\r\n      return result;\r\n    } catch (error) {\r\n      console.error('Transcription failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Change the Whisper model\r\n   * @param {string} modelName - New model name\r\n   * @returns {Promise<boolean>} Success status\r\n   */\r\n  async changeModel(modelName) {\r\n    if (!this.worker) {\r\n      throw new Error('Worker not available');\r\n    }\r\n\r\n    try {\r\n      const result = await this.sendMessage('changeModel', { modelName });\r\n      \r\n      if (result.success) {\r\n        this.currentModel = modelName;\r\n        console.log('Model changed to:', modelName);\r\n        return true;\r\n      } else {\r\n        throw new Error(result.error || 'Failed to change model');\r\n      }\r\n    } catch (error) {\r\n      console.error('Model change failed:', error);\r\n      this.handleError('Model change failed', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get available models\r\n   * @returns {Promise<Array>} Available model names\r\n   */\r\n  async getAvailableModels() {\r\n    if (!this.worker) {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      return await this.sendMessage('getAvailableModels');\r\n    } catch (error) {\r\n      console.error('Failed to get available models:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get model information\r\n   * @param {string} modelName - Model name\r\n   * @returns {Promise<Object>} Model info\r\n   */\r\n  async getModelInfo(modelName) {\r\n    if (!this.worker) {\r\n      return {};\r\n    }\r\n\r\n    try {\r\n      return await this.sendMessage('getModelInfo', { modelName });\r\n    } catch (error) {\r\n      console.error('Failed to get model info:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send message to worker and wait for response\r\n   * @param {string} type - Message type\r\n   * @param {Object} data - Message data\r\n   * @returns {Promise<any>} Response data\r\n   */\r\n  sendMessage(type, data = {}) {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.worker) {\r\n        reject(new Error('Worker not available'));\r\n        return;\r\n      }\r\n\r\n      const id = ++this.messageId;\r\n      \r\n      // Store promise resolvers\r\n      this.pendingMessages.set(id, { resolve, reject });\r\n\r\n      // Set timeout for message\r\n      const timeout = setTimeout(() => {\r\n        this.pendingMessages.delete(id);\r\n        reject(new Error(`Message timeout: ${type}`));\r\n      }, 60000); // 60 second timeout\r\n\r\n      // Clear timeout when message resolves\r\n      const originalResolve = resolve;\r\n      const originalReject = reject;\r\n      \r\n      this.pendingMessages.set(id, {\r\n        resolve: (data) => {\r\n          clearTimeout(timeout);\r\n          originalResolve(data);\r\n        },\r\n        reject: (error) => {\r\n          clearTimeout(timeout);\r\n          originalReject(error);\r\n        }\r\n      });\r\n\r\n      // Send message to worker\r\n      this.worker.postMessage({ id, type, data });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle messages from worker\r\n   * @param {MessageEvent} event - Worker message event\r\n   */\r\n  handleWorkerMessage(event) {\r\n    const { id, type, data } = event.data;\r\n\r\n    if (type === 'ready') {\r\n      // Already handled in waitForWorkerReady\r\n      return;\r\n    }\r\n\r\n    if (type === 'progress') {\r\n      // Handle progress updates\r\n      console.log('Model loading progress:', data.progress);\r\n      if (this.onProgress) {\r\n        this.onProgress(data.progress);\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (!id || !this.pendingMessages.has(id)) {\r\n      console.warn('Received message with unknown ID:', id);\r\n      return;\r\n    }\r\n\r\n    const { resolve, reject } = this.pendingMessages.get(id);\r\n    this.pendingMessages.delete(id);\r\n\r\n    if (type === 'success') {\r\n      resolve(data);\r\n    } else if (type === 'error') {\r\n      reject(new Error(data.message));\r\n    } else {\r\n      reject(new Error(`Unknown response type: ${type}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle worker errors\r\n   * @param {ErrorEvent} error - Worker error event\r\n   */\r\n  handleWorkerError(error) {\r\n    console.error('Worker error:', error);\r\n    this.handleError('Worker error', error);\r\n  }\r\n\r\n  /**\r\n   * Handle service errors\r\n   * @param {string} message - Error message\r\n   * @param {Error} error - Error object\r\n   */\r\n  handleError(message, error) {\r\n    console.error(message, error);\r\n    \r\n    if (this.onError) {\r\n      this.onError({\r\n        message,\r\n        error,\r\n        timestamp: Date.now()\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current status\r\n   * @returns {Object} Service status\r\n   */\r\n  getStatus() {\r\n    return {\r\n      isInitialized: this.isInitialized,\r\n      isInitializing: this.isInitializing,\r\n      currentModel: this.currentModel,\r\n      workerAvailable: !!this.worker,\r\n      pendingMessages: this.pendingMessages.size\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set ready callback\r\n   * @param {Function} callback - Ready callback\r\n   */\r\n  setReadyCallback(callback) {\r\n    this.onReady = callback;\r\n  }\r\n\r\n  /**\r\n   * Set error callback\r\n   * @param {Function} callback - Error callback\r\n   */\r\n  setErrorCallback(callback) {\r\n    this.onError = callback;\r\n  }\r\n\r\n  /**\r\n   * Set progress callback\r\n   * @param {Function} callback - Progress callback\r\n   */\r\n  setProgressCallback(callback) {\r\n    this.onProgress = callback;\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   */\r\n  async cleanup() {\r\n    try {\r\n      // Send cleanup message to worker\r\n      if (this.worker && this.isInitialized) {\r\n        await this.sendMessage('cleanup');\r\n      }\r\n    } catch (error) {\r\n      console.warn('Cleanup message failed:', error);\r\n    }\r\n\r\n    // Terminate worker\r\n    if (this.worker) {\r\n      this.worker.terminate();\r\n      this.worker = null;\r\n    }\r\n\r\n    // Clear pending messages\r\n    for (const [id, { reject }] of this.pendingMessages) {\r\n      reject(new Error('Service cleanup'));\r\n    }\r\n    this.pendingMessages.clear();\r\n\r\n    // Reset state\r\n    this.isInitialized = false;\r\n    this.isInitializing = false;\r\n    this.messageId = 0;\r\n\r\n    console.log('WhisperService cleaned up');\r\n  }\r\n}\r\n\r\nexport default WhisperService;"],"names":["constructor","this","worker","isInitialized","isInitializing","messageId","pendingMessages","Map","currentModel","onReady","onError","onProgress","initialize","modelName","arguments","length","undefined","Worker","error","console","Error","onmessage","handleWorkerMessage","bind","onerror","handleWorkerError","waitForWorkerReady","result","sendMessage","success","log","handleError","Promise","resolve","reject","timeout","setTimeout","handleMessage","event","data","type","clearTimeout","removeEventListener","addEventListener","transcribe","audioData","options","text","confidence","segments","processingTime","language","chunkLength","strideLength","changeModel","getAvailableModels","getModelInfo","id","set","delete","originalResolve","originalReject","postMessage","progress","has","warn","get","message","timestamp","Date","now","getStatus","workerAvailable","size","setReadyCallback","callback","setErrorCallback","setProgressCallback","cleanup","terminate","clear"],"sourceRoot":""}